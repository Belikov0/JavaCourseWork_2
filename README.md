# JavaCourseWork_2

## Java类的复用接口及集合

### 目的：

1. 掌握类复用的两种方式，继承与组合；

2. 掌握抽象类，接口，多态及它们在程序设计中应用。

3. 掌握接口（抽象类）->抽象类（接口）->具体类的三层设计架构，学习创建结构和行为模式。

4. 掌握List、Set、Map等几种集合的使用方法。

5. 文件的输入输出处理。

### 作业难度级别及分数比例：

*： 考查基础知识点，通过学习课件及例题可以仿照编写的程序。**（70%）**

\*\*：需要经过稍长时间思考，查看Java doc，程序稍微复杂，进一步熟练编程技巧。**（15%）**

\*\*\*: 比较灵活具有挑战性，需要花费较长的时间思考，有多种解决方案；或者课程中没有详细讲解，需要自己探索学习的课题。**（15%）**

仍然提交readme，包含程序运行结果并说明完成情况。

### 作业：

#### 1 **（35%）**

​	**参看Graphic Strikes Back要求文档，按照步骤实现要求并提供程序的UML类图。**

####  2  \***（10%）**

**（1）一个读者可以订阅一种或者几种报纸，根据提供的newscafe文件夹下的代码架构，补充代码功能，并验证结果。示例运行结果如下：**

```bash
Jill reads: The Times : Stormy weather!
Jill reads: The Guardian : Bad news!
Jack reads: The Guardian : Bad news!
Jill reads: The Guardian : Good news!
Jack reads: The Guardian : Good news!
Jill reads: The Times : Sunny weather!
```



####  3	\***（10%）** 

​	**创建一个DebitPayment父类类管理你的支付方式，类中包含银行账户，账户余额，信用卡账号，信用卡使用额度信息及操作。你的手机通常支持有支付宝，微信，京东,银联等支付方式，每种支付方式流程大同小异,采用多态机制，创建AliPay,WeChatPay,JDPay和UnionPay四个子类，分别以不同的方式重写DebitPayment类中的payMethod方法，支付类型有**

- “bank”--银行账号扣款,从bankBalance减去金额；
- “credit”--信用卡扣款，从creditLimit额度里减去金额;
- “bankfirst”—优先从银行bankBalance中扣款，如果bankBalance余额不足，再从信用卡扣款；
- “creditfirst”--优先从信用卡creditBalance中扣款，如果超出额度，再bankBalance扣款；

**支付类型可以定义为枚举类型PType，支付宝，微信，京东,银联支付时选择其中一种支付。以下是类DebitPayment的定义和其中一个子类AliPay的定义，你可以自行修改此类，添加构造方法或其他方法。**

```java
class DebitPayment{
     String bankAcct;        //银行账号
     double bankBalance;      //银行余额
     String creditCardNum;    //信用卡号
     double creditLimit;      //信用卡额度
     String payType;          //支付类型
    
    double payMethod(double cost，PType type){return 0.0}; //需要在子类中重写
    ……
}

class Alipay{
   String AliAcct;       //支付宝账户
	
   double payMethod(double cost, PType type){return… }   //需要实现的方法
}
```

**创建一个MyMobilePayment类，在main中创建一个用户对象，采用多态同时拥有支付宝，微信，京东,银联等支付功能，并验证银行账户余额或者信用卡额度的变化。提供UML类图。**

####  4 \* **（20%）**

**定义一个奇数类Odd，一个偶数类Even，在constructor里进行奇偶校验及异常处理。奇数偶数算术计算规则：**

- even ± even = even
- even ± odd = odd
- odd ± odd = even
- even × even = even
- even × odd = even
- odd × odd = odd

**（1）重写类中的toString，equal和hashCode方法。**

**（2）在两个类中实现add()和mutiply()方法，验证以上的计算规则，返回类型必须是Odd或者Even类型，不能是整数类型。**

**（3）用Set存储奇数或者偶数，以便删除重复的元素。**

####  5 \** **（10%）**

​	**实现过滤掉图片中的麻点，参考MedianFilter.java提供代码步骤，读取图片ship.png，进行去噪处理，得到清晰的图片。**

#### 6 \*\*\* (15%) 

​	生命游戏，又叫康威生命游戏(Conway’s Game of Life)，或康威生命棋，是英国数学家约翰·康威(John Conway)在1970年发明的细胞自动机。https://www.sohu.com/a/389463995_348129。生命游戏发生在一个二维矩形世界，每个方格居住着一个活着的或死了的细胞。一个细胞在下一个时刻生死取决于相邻八个方格中活着的细胞的数量。一方面，如果相邻方格活着的细胞数量过多，这个细胞会因为资源匮乏而在下一个时刻死去；另一方面，如果周围活细胞过少，这个细胞会因太孤单而死去。而只有其周围的细胞数量适合时，这个方格中的细胞才能继续存活。

对于任意细胞，游戏停留在2D矩阵，即2D图像中，细胞可以是“活的”(像素值255 -白色)或“死的”(像素值0 -黑色)。游戏进化是由其初始状态决定的（从images.zip中的pgm图读取），不需要从键盘输入。每个细胞与它的8个相邻像素(细胞)相互作用:水平、垂直或对角相邻的细胞。在每次矩阵更新时，以下变化可能会产生域的下一个演进，规则如下：

（1）每个细胞有两种状态-存活或死亡，每个细胞与以自身为中心的周围八个细胞产生互动。

（2）当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）

（3）当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟人口稀少）

（4）当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。

（5）当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟过度拥挤）

初始状态被以上规则处理后, 可以得到第一代细胞图。继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。在游戏的进行中，杂乱无序的细胞会逐渐演化出各种精致、有形的结构。将图像考虑为一个封闭域(顶部一行的像素连接到底部一行的像素，右边的像素连接到左边的像素，反之亦然)，重写方法，用图形将其几代展示出来。用户通过创建初始配置并观察它如何演变。
